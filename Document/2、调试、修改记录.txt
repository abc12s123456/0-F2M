2023.03.27
一、(框架)需要解决的问题：
1、支持扩展；
2、支持多任务；
3、硬件隔离(尽量不体现任何硬件特征)；

二、框架的作用
1、对上提供统一的API()；


2023.03.29
1、初步目标：MCU无关；


2023.03.30
1、设备扩展方式：继承与组合，例如：
   ESP8266使用继承的方式，通过UART进行操作；
   直流电机驱动中需要使用PWM&ADC，则使用组合方式；
   多个设备共用同一个端口时，使用引用方式(指针)；

2、继承方式可直接使用FW_Device_Open/Close，组合方式需要自定义Open/Close供
FW_Device_Open/Close调用；

3、继承以实例的方式定义，组合以指针的方式定义；

2023.03.31
1、具体的驱动独立定义、注册；设备通过驱动ID去匹配对应的驱动；
2、希望通过设备ID唯一对应到设备驱动；

Device_ID:
type(8b) + driver(8b) + port(8b) + channel(8b)

3、定义一个设备，如何关联到对应的驱动上？
   通过Device_ID可以唯一确定使用的驱动Driver_ID(type + driver)
   
2023.04.03
1、MDK是按照同一个文件夹下.c文件的排列顺序进行编译的
2、框架应做到编译顺序无关；

2023.04.07
1、DRV的编号问题：
   具体实现 = DT + DRV，即不同的DT下DRV可以相同；
2、应在前期初始化时，检查设备、驱动是否有重复；
3、以SPI为例，SPI可以驱动多种设备，不同的设备在定义时进行区分：
   #define SPI_DEV0  FW_DEVICE_ID(FW_DT_SPI, DRV, 0, NULL)
   #define SPI_DEV1  FW_DEVICE_ID(FW_DT_SPI, DRV, 1, NULL)
   SPI_DEV0与SPI_DEV1使用相同的DRV,使用SN进行区分
   
   #define SPI_DEV2  FW_DEVICE_ID(FW_DT_SPI, DRV2, NULL, NULL)
   #define SPI_DEV3  FW_DEVICE_ID(FW_DT_SPI, DRV3, NULL, NULL)
   SPI_DEV2与SPI_DEV3使用不同的DRV

2023.04.10
1、设备、驱动定义表示的含义：
   #define SPI_DEV0  FW_DEVICE_ID(FW_DT_SPI, SPI_NATIVE_DRV_NUM, 0, NULL)
   表示使用原生SPI驱动，端口为SPI0
   
   #define GD25Q64_DEV  FW_DEVICE_ID(FW_DT_SPI_Device, SNOR_FLASH_DRV_NUM, NULL, NULL)
   表示使用SPI驱动NOR Flash


   SPI_DRV_ID        FW_DRIVER_ID(FW_DT_SPI, SPI_NATIVE_DRV_NUM)
   
2023.04.11
1、引用顺序
   Flash_Device <-- Flash_Driver
					    /\
					    ||
			   SNOR_Device(GD25Q64/32...) <-- SNOR_Flash_Driver
													  /\
													  ||
										   SPI_Device(SPI0/1/2...) <-- FW_SPI_Driver
																			 /\
																			 ||
																		   LL实例


	/* 定义Flash设备ID，使用SNOR驱动 */
	#define FLASH_DEV_ID       FW_DEVICE_ID(FW_DT_Flash, SNOR_DRV_NUM, NULL, NULL)
	
	/* 定义Flash设备 */
	FW_Flash_Type Flash0;
	
	/* 注册Flash设备 */
	static void Flash0_Config(void *dev)
	{
	
	}
	FW_DEVICE_REGISTER(FLASH_DEV_ID, &Flash0, Flash0_Config, Flash0);
	
	
	/* 定义SNOR设备ID，使用SPI驱动 */
	#define GD25Q64_DEV_ID        FW_DEVICE_ID(FW_DT_xxxx, SPI_DRV_NUM, NULL, NULL)
	
	/* 定义SNOR设备 */
	SNOR_Type GD25Q64;
	
	/* 注册SNOR设备 */
	static void GD25Q64_Config(void *dev)
	{
	
	}
	FW_DEVICE_REGISTER(GD25Q64_DEV_ID, &GD25Q64, GD25Q64_Config, GD25Q64);
	
2、多实例的驱动需要在定义时关联具体的实现设备，或者换一种说法是，在定义一个
设备时，需要将其关联到将要支持的驱动

3、具有继承的设备，需要明确父设备
	
2023.04.12
1、通过Device_ID关联设备？

2023.04.13
1、Main函数执行前的所有用户操作(通过分布式加载)，不执行任何硬件操作(初始化、读、
   写、控制等)，防止因系统尚未初始化，导致系统异常

2、考虑多任务时，设备资源共享的问题

2023.04.14
1、多任务时，设备在执行open操作时，首先递归查找是否具有Parent.Device，直到当前设
   备及所有Parent.Device都处于空闲时，才会返回open成功。此时，所有相关的设备都应
   标记为占用状态；若在查找过程中，任意设备已被占用，则直接返回open失败
   
   a. 关闭任务调度
   b. dev --> p1 --> p2 --> ... --> pn --> NULL
   c. dev.oflag = 1 --> p1.oflag = 1 --> ... --> pn.oflag = 1
   d. 打开任务调度
   
2、open操作时，应关闭任务调度，防止在其它更高优先级任务中对已判断空闲的设备执行open
   操作
   
3、执行close操作时，以ref_count判断是否执行设备的close操作

2023.07.23
1、最小系统包括：
   a、System
   b、Delay
   c、GPIO
   这三个模块的底层驱动若为空，则程序将不再继续执行；
2、设备ID替换为Name，即设备定义时，以字符串名称作为自身标记。原因在于，使用ID标记
   时，设备编号、外设编号、通道编号、驱动编号的组合容易混淆且不直观，当项目较大时，
   问题会更严重。使用字符串标识，会占用较大的存储空间(ID占用4B, Name占用8B(定义了
   一个最大字符长度))，但直观，明确。
   

2023.09.01
1、dev与drv的映射关系：
   a、一个dev只能有一个drv，即一个dev只能有一个父设备；
   b、一个drv可以调用多个dev，即一个dev可以作为多个设备的父设备；
   
2023.09.06
1、Flash的读写以字节为最小操作单元；
2、若底层的最小操作单元超过一个字节，则由底层自行调节；
   
2023.10.11
1、对于flash, wdg这类设备，在函数命名时，操作语后直接连接具体的名称，而无需加下划线
   进行分割，例如 WDG_FeedDog(dev)对应PAL层的FW_WDG_FeedDog()，能更好的保证名称的一
   致性;

2023.10.17
1、在编写底层驱动时，通过if-else/switch-case/?-:这一类形式进行映射时，非常占用存储
   空间(主要是ROM)及运算速度(大多数为初始化调用，影响还小点)，因此在对存储及运行速
   度有要求时，可以通过逻辑运算进行映射(程序的可读性变差，需要去计算，费事)；
2、单独一行if-else占用4B ROM，所以当不同的if-else执行结果相同时，应合并而不是单独
   写一行；

2023.10.22
1、MDK运行时定义的设备，定义完成后，设备若未初始化，则系统会随机赋值。

2023.10.29
1、应用程序的条理逻辑应该清晰；
2、应用程序应该隐藏具体的硬件逻辑；

2023.12.27
1、除底层外，存储设备的地址方式统一设置为相对地址：0 ~ (Size - 1);

2024.04.03
1、驱动链接的标识由u32类型参数变为string类型，以“drv->dev”的方式表示；

2024.04.08
1、修复了模拟SPI读写操作中存在的bug；
2、优化了SPI、I2C、UART驱动外设时的驱动模式；

2024.04.16
1、调试PWM过程中，调用Timer时，寄存器一直为0，无法设置，原因是未使能相应的时钟；
   相同的现象，一般也可以查看外设时钟是否使能；
2、Timer PWM硬件仿真过程中，CTL0/1、CHCTL2等控制寄存器的值始终为0，但是功能正常，
   CNT、CAR、CHxCV等寄存器值正常；

2024.04.17
1、编译LVGL时，存储占用过大。可调整lv_conf.h中LV_MEM_SIZE的值(LVGL动态内存分配占用)。

2024.04.19
1、修复了FW_Delay_GetUsDuration中的逻辑问题，当前结果还存在少许偏差(约8~9us)。

2024.04.20
1、修复了FW_Delay_GetUsDuration存在的偏差；
2、在FW_OS_Start中增加了FW_Delay_Init，保证RTOS使用后，FW_Delay_Ms能关联到OS的延时上。

2024.04.22
1、增加系统上电后的延时时间统计。系统异常情况(例如咬狗复位)由应用层处理。

2024.04.26
1、由于LVGL的编码格式为UTF-8,为了编码格式统一，F2M框架的编码格式全部由GB2312转换
   为UTF-8(MDK下为Encode in UTF-8 without signature)

2024.04.30


